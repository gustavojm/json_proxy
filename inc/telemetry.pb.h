// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: telemetry.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_telemetry_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_telemetry_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_telemetry_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_telemetry_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_telemetry_2eproto;
namespace telemetry_proto {
class CompoundAxes;
struct CompoundAxesDefaultTypeInternal;
extern CompoundAxesDefaultTypeInternal _CompoundAxes_default_instance_;
class IndividualAxes;
struct IndividualAxesDefaultTypeInternal;
extern IndividualAxesDefaultTypeInternal _IndividualAxes_default_instance_;
class Limits;
struct LimitsDefaultTypeInternal;
extern LimitsDefaultTypeInternal _Limits_default_instance_;
class Point3D;
struct Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class Telemetry;
struct TelemetryDefaultTypeInternal;
extern TelemetryDefaultTypeInternal _Telemetry_default_instance_;
class Temps;
struct TempsDefaultTypeInternal;
extern TempsDefaultTypeInternal _Temps_default_instance_;
}  // namespace telemetry_proto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace telemetry_proto {

// ===================================================================


// -------------------------------------------------------------------

class Temps :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_proto.Temps) */ {
 public:
  inline Temps() : Temps(nullptr) {}
  ~Temps() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Temps(::google::protobuf::internal::ConstantInitialized);

  inline Temps(const Temps& from)
      : Temps(nullptr, from) {}
  Temps(Temps&& from) noexcept
    : Temps() {
    *this = ::std::move(from);
  }

  inline Temps& operator=(const Temps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Temps& operator=(Temps&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Temps& default_instance() {
    return *internal_default_instance();
  }
  static inline const Temps* internal_default_instance() {
    return reinterpret_cast<const Temps*>(
               &_Temps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Temps& a, Temps& b) {
    a.Swap(&b);
  }
  inline void Swap(Temps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Temps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Temps* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Temps>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Temps& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Temps& from) {
    Temps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Temps* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "telemetry_proto.Temps";
  }
  protected:
  explicit Temps(::google::protobuf::Arena* arena);
  Temps(::google::protobuf::Arena* arena, const Temps& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry_proto.Temps)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2eproto;
};// -------------------------------------------------------------------

class Point3D :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_proto.Point3D) */ {
 public:
  inline Point3D() : Point3D(nullptr) {}
  ~Point3D() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Point3D(::google::protobuf::internal::ConstantInitialized);

  inline Point3D(const Point3D& from)
      : Point3D(nullptr, from) {}
  Point3D(Point3D&& from) noexcept
    : Point3D() {
    *this = ::std::move(from);
  }

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point3D& operator=(Point3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point3D* internal_default_instance() {
    return reinterpret_cast<const Point3D*>(
               &_Point3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point3D& a, Point3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point3D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point3D* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point3D* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point3D>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Point3D& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Point3D& from) {
    Point3D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Point3D* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "telemetry_proto.Point3D";
  }
  protected:
  explicit Point3D(::google::protobuf::Arena* arena);
  Point3D(::google::protobuf::Arena* arena, const Point3D& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry_proto.Point3D)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2eproto;
};// -------------------------------------------------------------------

class Limits :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_proto.Limits) */ {
 public:
  inline Limits() : Limits(nullptr) {}
  ~Limits() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Limits(::google::protobuf::internal::ConstantInitialized);

  inline Limits(const Limits& from)
      : Limits(nullptr, from) {}
  Limits(Limits&& from) noexcept
    : Limits() {
    *this = ::std::move(from);
  }

  inline Limits& operator=(const Limits& from) {
    CopyFrom(from);
    return *this;
  }
  inline Limits& operator=(Limits&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Limits& default_instance() {
    return *internal_default_instance();
  }
  static inline const Limits* internal_default_instance() {
    return reinterpret_cast<const Limits*>(
               &_Limits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Limits& a, Limits& b) {
    a.Swap(&b);
  }
  inline void Swap(Limits* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Limits* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Limits* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Limits>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Limits& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Limits& from) {
    Limits::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Limits* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "telemetry_proto.Limits";
  }
  protected:
  explicit Limits(::google::protobuf::Arena* arena);
  Limits(::google::protobuf::Arena* arena, const Limits& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kUpFieldNumber = 3,
    kDownFieldNumber = 4,
    kInFieldNumber = 5,
    kOutFieldNumber = 6,
    kProbeFieldNumber = 7,
  };
  // bool left = 1;
  void clear_left() ;
  bool left() const;
  void set_left(bool value);

  private:
  bool _internal_left() const;
  void _internal_set_left(bool value);

  public:
  // bool right = 2;
  void clear_right() ;
  bool right() const;
  void set_right(bool value);

  private:
  bool _internal_right() const;
  void _internal_set_right(bool value);

  public:
  // bool up = 3;
  void clear_up() ;
  bool up() const;
  void set_up(bool value);

  private:
  bool _internal_up() const;
  void _internal_set_up(bool value);

  public:
  // bool down = 4;
  void clear_down() ;
  bool down() const;
  void set_down(bool value);

  private:
  bool _internal_down() const;
  void _internal_set_down(bool value);

  public:
  // bool in = 5;
  void clear_in() ;
  bool in() const;
  void set_in(bool value);

  private:
  bool _internal_in() const;
  void _internal_set_in(bool value);

  public:
  // bool out = 6;
  void clear_out() ;
  bool out() const;
  void set_out(bool value);

  private:
  bool _internal_out() const;
  void _internal_set_out(bool value);

  public:
  // bool probe = 7;
  void clear_probe() ;
  bool probe() const;
  void set_probe(bool value);

  private:
  bool _internal_probe() const;
  void _internal_set_probe(bool value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry_proto.Limits)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool left_;
    bool right_;
    bool up_;
    bool down_;
    bool in_;
    bool out_;
    bool probe_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2eproto;
};// -------------------------------------------------------------------

class IndividualAxes :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_proto.IndividualAxes) */ {
 public:
  inline IndividualAxes() : IndividualAxes(nullptr) {}
  ~IndividualAxes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IndividualAxes(::google::protobuf::internal::ConstantInitialized);

  inline IndividualAxes(const IndividualAxes& from)
      : IndividualAxes(nullptr, from) {}
  IndividualAxes(IndividualAxes&& from) noexcept
    : IndividualAxes() {
    *this = ::std::move(from);
  }

  inline IndividualAxes& operator=(const IndividualAxes& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndividualAxes& operator=(IndividualAxes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndividualAxes& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndividualAxes* internal_default_instance() {
    return reinterpret_cast<const IndividualAxes*>(
               &_IndividualAxes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IndividualAxes& a, IndividualAxes& b) {
    a.Swap(&b);
  }
  inline void Swap(IndividualAxes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndividualAxes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndividualAxes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndividualAxes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IndividualAxes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IndividualAxes& from) {
    IndividualAxes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IndividualAxes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "telemetry_proto.IndividualAxes";
  }
  protected:
  explicit IndividualAxes(::google::protobuf::Arena* arena);
  IndividualAxes(::google::protobuf::Arena* arena, const IndividualAxes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // bool x = 1;
  void clear_x() ;
  bool x() const;
  void set_x(bool value);

  private:
  bool _internal_x() const;
  void _internal_set_x(bool value);

  public:
  // bool y = 2;
  void clear_y() ;
  bool y() const;
  void set_y(bool value);

  private:
  bool _internal_y() const;
  void _internal_set_y(bool value);

  public:
  // bool z = 3;
  void clear_z() ;
  bool z() const;
  void set_z(bool value);

  private:
  bool _internal_z() const;
  void _internal_set_z(bool value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry_proto.IndividualAxes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool x_;
    bool y_;
    bool z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2eproto;
};// -------------------------------------------------------------------

class CompoundAxes :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_proto.CompoundAxes) */ {
 public:
  inline CompoundAxes() : CompoundAxes(nullptr) {}
  ~CompoundAxes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompoundAxes(::google::protobuf::internal::ConstantInitialized);

  inline CompoundAxes(const CompoundAxes& from)
      : CompoundAxes(nullptr, from) {}
  CompoundAxes(CompoundAxes&& from) noexcept
    : CompoundAxes() {
    *this = ::std::move(from);
  }

  inline CompoundAxes& operator=(const CompoundAxes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompoundAxes& operator=(CompoundAxes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompoundAxes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompoundAxes* internal_default_instance() {
    return reinterpret_cast<const CompoundAxes*>(
               &_CompoundAxes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CompoundAxes& a, CompoundAxes& b) {
    a.Swap(&b);
  }
  inline void Swap(CompoundAxes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompoundAxes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompoundAxes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompoundAxes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompoundAxes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CompoundAxes& from) {
    CompoundAxes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CompoundAxes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "telemetry_proto.CompoundAxes";
  }
  protected:
  explicit CompoundAxes(::google::protobuf::Arena* arena);
  CompoundAxes(::google::protobuf::Arena* arena, const CompoundAxes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXYFieldNumber = 1,
    kZFieldNumber = 2,
  };
  // bool x_y = 1;
  void clear_x_y() ;
  bool x_y() const;
  void set_x_y(bool value);

  private:
  bool _internal_x_y() const;
  void _internal_set_x_y(bool value);

  public:
  // bool z = 2;
  void clear_z() ;
  bool z() const;
  void set_z(bool value);

  private:
  bool _internal_z() const;
  void _internal_set_z(bool value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry_proto.CompoundAxes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool x_y_;
    bool z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2eproto;
};// -------------------------------------------------------------------

class Telemetry :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry_proto.Telemetry) */ {
 public:
  inline Telemetry() : Telemetry(nullptr) {}
  ~Telemetry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Telemetry(::google::protobuf::internal::ConstantInitialized);

  inline Telemetry(const Telemetry& from)
      : Telemetry(nullptr, from) {}
  Telemetry(Telemetry&& from) noexcept
    : Telemetry() {
    *this = ::std::move(from);
  }

  inline Telemetry& operator=(const Telemetry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Telemetry& operator=(Telemetry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Telemetry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Telemetry* internal_default_instance() {
    return reinterpret_cast<const Telemetry*>(
               &_Telemetry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Telemetry& a, Telemetry& b) {
    a.Swap(&b);
  }
  inline void Swap(Telemetry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Telemetry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Telemetry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Telemetry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Telemetry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Telemetry& from) {
    Telemetry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Telemetry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "telemetry_proto.Telemetry";
  }
  protected:
  explicit Telemetry(::google::protobuf::Arena* arena);
  Telemetry(::google::protobuf::Arena* arena, const Telemetry& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordsFieldNumber = 1,
    kTargetsFieldNumber = 2,
    kOnConditionFieldNumber = 3,
    kProbeFieldNumber = 4,
    kStalledFieldNumber = 5,
    kLimitsFieldNumber = 6,
    kTempsFieldNumber = 11,
    kControlEnabledFieldNumber = 7,
    kStallControlFieldNumber = 8,
    kProbeProtectedFieldNumber = 10,
    kBrakesModeFieldNumber = 9,
  };
  // .telemetry_proto.Point3D coords = 1;
  bool has_coords() const;
  void clear_coords() ;
  const ::telemetry_proto::Point3D& coords() const;
  PROTOBUF_NODISCARD ::telemetry_proto::Point3D* release_coords();
  ::telemetry_proto::Point3D* mutable_coords();
  void set_allocated_coords(::telemetry_proto::Point3D* value);
  void unsafe_arena_set_allocated_coords(::telemetry_proto::Point3D* value);
  ::telemetry_proto::Point3D* unsafe_arena_release_coords();

  private:
  const ::telemetry_proto::Point3D& _internal_coords() const;
  ::telemetry_proto::Point3D* _internal_mutable_coords();

  public:
  // .telemetry_proto.Point3D targets = 2;
  bool has_targets() const;
  void clear_targets() ;
  const ::telemetry_proto::Point3D& targets() const;
  PROTOBUF_NODISCARD ::telemetry_proto::Point3D* release_targets();
  ::telemetry_proto::Point3D* mutable_targets();
  void set_allocated_targets(::telemetry_proto::Point3D* value);
  void unsafe_arena_set_allocated_targets(::telemetry_proto::Point3D* value);
  ::telemetry_proto::Point3D* unsafe_arena_release_targets();

  private:
  const ::telemetry_proto::Point3D& _internal_targets() const;
  ::telemetry_proto::Point3D* _internal_mutable_targets();

  public:
  // .telemetry_proto.CompoundAxes on_condition = 3;
  bool has_on_condition() const;
  void clear_on_condition() ;
  const ::telemetry_proto::CompoundAxes& on_condition() const;
  PROTOBUF_NODISCARD ::telemetry_proto::CompoundAxes* release_on_condition();
  ::telemetry_proto::CompoundAxes* mutable_on_condition();
  void set_allocated_on_condition(::telemetry_proto::CompoundAxes* value);
  void unsafe_arena_set_allocated_on_condition(::telemetry_proto::CompoundAxes* value);
  ::telemetry_proto::CompoundAxes* unsafe_arena_release_on_condition();

  private:
  const ::telemetry_proto::CompoundAxes& _internal_on_condition() const;
  ::telemetry_proto::CompoundAxes* _internal_mutable_on_condition();

  public:
  // .telemetry_proto.CompoundAxes probe = 4;
  bool has_probe() const;
  void clear_probe() ;
  const ::telemetry_proto::CompoundAxes& probe() const;
  PROTOBUF_NODISCARD ::telemetry_proto::CompoundAxes* release_probe();
  ::telemetry_proto::CompoundAxes* mutable_probe();
  void set_allocated_probe(::telemetry_proto::CompoundAxes* value);
  void unsafe_arena_set_allocated_probe(::telemetry_proto::CompoundAxes* value);
  ::telemetry_proto::CompoundAxes* unsafe_arena_release_probe();

  private:
  const ::telemetry_proto::CompoundAxes& _internal_probe() const;
  ::telemetry_proto::CompoundAxes* _internal_mutable_probe();

  public:
  // .telemetry_proto.IndividualAxes stalled = 5;
  bool has_stalled() const;
  void clear_stalled() ;
  const ::telemetry_proto::IndividualAxes& stalled() const;
  PROTOBUF_NODISCARD ::telemetry_proto::IndividualAxes* release_stalled();
  ::telemetry_proto::IndividualAxes* mutable_stalled();
  void set_allocated_stalled(::telemetry_proto::IndividualAxes* value);
  void unsafe_arena_set_allocated_stalled(::telemetry_proto::IndividualAxes* value);
  ::telemetry_proto::IndividualAxes* unsafe_arena_release_stalled();

  private:
  const ::telemetry_proto::IndividualAxes& _internal_stalled() const;
  ::telemetry_proto::IndividualAxes* _internal_mutable_stalled();

  public:
  // .telemetry_proto.Limits limits = 6;
  bool has_limits() const;
  void clear_limits() ;
  const ::telemetry_proto::Limits& limits() const;
  PROTOBUF_NODISCARD ::telemetry_proto::Limits* release_limits();
  ::telemetry_proto::Limits* mutable_limits();
  void set_allocated_limits(::telemetry_proto::Limits* value);
  void unsafe_arena_set_allocated_limits(::telemetry_proto::Limits* value);
  ::telemetry_proto::Limits* unsafe_arena_release_limits();

  private:
  const ::telemetry_proto::Limits& _internal_limits() const;
  ::telemetry_proto::Limits* _internal_mutable_limits();

  public:
  // .telemetry_proto.Temps temps = 11;
  bool has_temps() const;
  void clear_temps() ;
  const ::telemetry_proto::Temps& temps() const;
  PROTOBUF_NODISCARD ::telemetry_proto::Temps* release_temps();
  ::telemetry_proto::Temps* mutable_temps();
  void set_allocated_temps(::telemetry_proto::Temps* value);
  void unsafe_arena_set_allocated_temps(::telemetry_proto::Temps* value);
  ::telemetry_proto::Temps* unsafe_arena_release_temps();

  private:
  const ::telemetry_proto::Temps& _internal_temps() const;
  ::telemetry_proto::Temps* _internal_mutable_temps();

  public:
  // bool control_enabled = 7;
  void clear_control_enabled() ;
  bool control_enabled() const;
  void set_control_enabled(bool value);

  private:
  bool _internal_control_enabled() const;
  void _internal_set_control_enabled(bool value);

  public:
  // bool stall_control = 8;
  void clear_stall_control() ;
  bool stall_control() const;
  void set_stall_control(bool value);

  private:
  bool _internal_stall_control() const;
  void _internal_set_stall_control(bool value);

  public:
  // bool probe_protected = 10;
  void clear_probe_protected() ;
  bool probe_protected() const;
  void set_probe_protected(bool value);

  private:
  bool _internal_probe_protected() const;
  void _internal_set_probe_protected(bool value);

  public:
  // int32 brakes_mode = 9;
  void clear_brakes_mode() ;
  ::int32_t brakes_mode() const;
  void set_brakes_mode(::int32_t value);

  private:
  ::int32_t _internal_brakes_mode() const;
  void _internal_set_brakes_mode(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry_proto.Telemetry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 7,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::telemetry_proto::Point3D* coords_;
    ::telemetry_proto::Point3D* targets_;
    ::telemetry_proto::CompoundAxes* on_condition_;
    ::telemetry_proto::CompoundAxes* probe_;
    ::telemetry_proto::IndividualAxes* stalled_;
    ::telemetry_proto::Limits* limits_;
    ::telemetry_proto::Temps* temps_;
    bool control_enabled_;
    bool stall_control_;
    bool probe_protected_;
    ::int32_t brakes_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Point3D

// double x = 1;
inline void Point3D::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Point3D::x() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Point3D.x)
  return _internal_x();
}
inline void Point3D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Point3D.x)
}
inline double Point3D::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Point3D::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2;
inline void Point3D::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Point3D::y() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Point3D.y)
  return _internal_y();
}
inline void Point3D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Point3D.y)
}
inline double Point3D::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Point3D::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 3;
inline void Point3D::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Point3D::z() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Point3D.z)
  return _internal_z();
}
inline void Point3D::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Point3D.z)
}
inline double Point3D::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Point3D::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Temps

// double x = 1;
inline void Temps::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Temps::x() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Temps.x)
  return _internal_x();
}
inline void Temps::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Temps.x)
}
inline double Temps::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Temps::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2;
inline void Temps::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Temps::y() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Temps.y)
  return _internal_y();
}
inline void Temps::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Temps.y)
}
inline double Temps::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Temps::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 3;
inline void Temps::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Temps::z() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Temps.z)
  return _internal_z();
}
inline void Temps::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Temps.z)
}
inline double Temps::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Temps::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// IndividualAxes

// bool x = 1;
inline void IndividualAxes::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = false;
}
inline bool IndividualAxes::x() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.IndividualAxes.x)
  return _internal_x();
}
inline void IndividualAxes::set_x(bool value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.IndividualAxes.x)
}
inline bool IndividualAxes::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void IndividualAxes::_internal_set_x(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// bool y = 2;
inline void IndividualAxes::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = false;
}
inline bool IndividualAxes::y() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.IndividualAxes.y)
  return _internal_y();
}
inline void IndividualAxes::set_y(bool value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.IndividualAxes.y)
}
inline bool IndividualAxes::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void IndividualAxes::_internal_set_y(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// bool z = 3;
inline void IndividualAxes::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = false;
}
inline bool IndividualAxes::z() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.IndividualAxes.z)
  return _internal_z();
}
inline void IndividualAxes::set_z(bool value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.IndividualAxes.z)
}
inline bool IndividualAxes::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void IndividualAxes::_internal_set_z(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Limits

// bool left = 1;
inline void Limits::clear_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_ = false;
}
inline bool Limits::left() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Limits.left)
  return _internal_left();
}
inline void Limits::set_left(bool value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Limits.left)
}
inline bool Limits::_internal_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.left_;
}
inline void Limits::_internal_set_left(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_ = value;
}

// bool right = 2;
inline void Limits::clear_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.right_ = false;
}
inline bool Limits::right() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Limits.right)
  return _internal_right();
}
inline void Limits::set_right(bool value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Limits.right)
}
inline bool Limits::_internal_right() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.right_;
}
inline void Limits::_internal_set_right(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.right_ = value;
}

// bool up = 3;
inline void Limits::clear_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.up_ = false;
}
inline bool Limits::up() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Limits.up)
  return _internal_up();
}
inline void Limits::set_up(bool value) {
  _internal_set_up(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Limits.up)
}
inline bool Limits::_internal_up() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.up_;
}
inline void Limits::_internal_set_up(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.up_ = value;
}

// bool down = 4;
inline void Limits::clear_down() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.down_ = false;
}
inline bool Limits::down() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Limits.down)
  return _internal_down();
}
inline void Limits::set_down(bool value) {
  _internal_set_down(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Limits.down)
}
inline bool Limits::_internal_down() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.down_;
}
inline void Limits::_internal_set_down(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.down_ = value;
}

// bool in = 5;
inline void Limits::clear_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.in_ = false;
}
inline bool Limits::in() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Limits.in)
  return _internal_in();
}
inline void Limits::set_in(bool value) {
  _internal_set_in(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Limits.in)
}
inline bool Limits::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline void Limits::_internal_set_in(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.in_ = value;
}

// bool out = 6;
inline void Limits::clear_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.out_ = false;
}
inline bool Limits::out() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Limits.out)
  return _internal_out();
}
inline void Limits::set_out(bool value) {
  _internal_set_out(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Limits.out)
}
inline bool Limits::_internal_out() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.out_;
}
inline void Limits::_internal_set_out(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.out_ = value;
}

// bool probe = 7;
inline void Limits::clear_probe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.probe_ = false;
}
inline bool Limits::probe() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Limits.probe)
  return _internal_probe();
}
inline void Limits::set_probe(bool value) {
  _internal_set_probe(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Limits.probe)
}
inline bool Limits::_internal_probe() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.probe_;
}
inline void Limits::_internal_set_probe(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.probe_ = value;
}

// -------------------------------------------------------------------

// CompoundAxes

// bool x_y = 1;
inline void CompoundAxes::clear_x_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_y_ = false;
}
inline bool CompoundAxes::x_y() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.CompoundAxes.x_y)
  return _internal_x_y();
}
inline void CompoundAxes::set_x_y(bool value) {
  _internal_set_x_y(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.CompoundAxes.x_y)
}
inline bool CompoundAxes::_internal_x_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_y_;
}
inline void CompoundAxes::_internal_set_x_y(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_y_ = value;
}

// bool z = 2;
inline void CompoundAxes::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = false;
}
inline bool CompoundAxes::z() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.CompoundAxes.z)
  return _internal_z();
}
inline void CompoundAxes::set_z(bool value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.CompoundAxes.z)
}
inline bool CompoundAxes::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void CompoundAxes::_internal_set_z(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Telemetry

// .telemetry_proto.Point3D coords = 1;
inline bool Telemetry::has_coords() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coords_ != nullptr);
  return value;
}
inline void Telemetry::clear_coords() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.coords_ != nullptr) _impl_.coords_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::telemetry_proto::Point3D& Telemetry::_internal_coords() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::telemetry_proto::Point3D* p = _impl_.coords_;
  return p != nullptr ? *p : reinterpret_cast<const ::telemetry_proto::Point3D&>(::telemetry_proto::_Point3D_default_instance_);
}
inline const ::telemetry_proto::Point3D& Telemetry::coords() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.coords)
  return _internal_coords();
}
inline void Telemetry::unsafe_arena_set_allocated_coords(::telemetry_proto::Point3D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.coords_);
  }
  _impl_.coords_ = reinterpret_cast<::telemetry_proto::Point3D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry_proto.Telemetry.coords)
}
inline ::telemetry_proto::Point3D* Telemetry::release_coords() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::telemetry_proto::Point3D* released = _impl_.coords_;
  _impl_.coords_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::telemetry_proto::Point3D* Telemetry::unsafe_arena_release_coords() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:telemetry_proto.Telemetry.coords)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::telemetry_proto::Point3D* temp = _impl_.coords_;
  _impl_.coords_ = nullptr;
  return temp;
}
inline ::telemetry_proto::Point3D* Telemetry::_internal_mutable_coords() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.coords_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_proto::Point3D>(GetArena());
    _impl_.coords_ = reinterpret_cast<::telemetry_proto::Point3D*>(p);
  }
  return _impl_.coords_;
}
inline ::telemetry_proto::Point3D* Telemetry::mutable_coords() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry_proto::Point3D* _msg = _internal_mutable_coords();
  // @@protoc_insertion_point(field_mutable:telemetry_proto.Telemetry.coords)
  return _msg;
}
inline void Telemetry::set_allocated_coords(::telemetry_proto::Point3D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::telemetry_proto::Point3D*>(_impl_.coords_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::telemetry_proto::Point3D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.coords_ = reinterpret_cast<::telemetry_proto::Point3D*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry_proto.Telemetry.coords)
}

// .telemetry_proto.Point3D targets = 2;
inline bool Telemetry::has_targets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.targets_ != nullptr);
  return value;
}
inline void Telemetry::clear_targets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.targets_ != nullptr) _impl_.targets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::telemetry_proto::Point3D& Telemetry::_internal_targets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::telemetry_proto::Point3D* p = _impl_.targets_;
  return p != nullptr ? *p : reinterpret_cast<const ::telemetry_proto::Point3D&>(::telemetry_proto::_Point3D_default_instance_);
}
inline const ::telemetry_proto::Point3D& Telemetry::targets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.targets)
  return _internal_targets();
}
inline void Telemetry::unsafe_arena_set_allocated_targets(::telemetry_proto::Point3D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.targets_);
  }
  _impl_.targets_ = reinterpret_cast<::telemetry_proto::Point3D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry_proto.Telemetry.targets)
}
inline ::telemetry_proto::Point3D* Telemetry::release_targets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::telemetry_proto::Point3D* released = _impl_.targets_;
  _impl_.targets_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::telemetry_proto::Point3D* Telemetry::unsafe_arena_release_targets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:telemetry_proto.Telemetry.targets)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::telemetry_proto::Point3D* temp = _impl_.targets_;
  _impl_.targets_ = nullptr;
  return temp;
}
inline ::telemetry_proto::Point3D* Telemetry::_internal_mutable_targets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.targets_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_proto::Point3D>(GetArena());
    _impl_.targets_ = reinterpret_cast<::telemetry_proto::Point3D*>(p);
  }
  return _impl_.targets_;
}
inline ::telemetry_proto::Point3D* Telemetry::mutable_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry_proto::Point3D* _msg = _internal_mutable_targets();
  // @@protoc_insertion_point(field_mutable:telemetry_proto.Telemetry.targets)
  return _msg;
}
inline void Telemetry::set_allocated_targets(::telemetry_proto::Point3D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::telemetry_proto::Point3D*>(_impl_.targets_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::telemetry_proto::Point3D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.targets_ = reinterpret_cast<::telemetry_proto::Point3D*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry_proto.Telemetry.targets)
}

// .telemetry_proto.CompoundAxes on_condition = 3;
inline bool Telemetry::has_on_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.on_condition_ != nullptr);
  return value;
}
inline void Telemetry::clear_on_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.on_condition_ != nullptr) _impl_.on_condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::telemetry_proto::CompoundAxes& Telemetry::_internal_on_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::telemetry_proto::CompoundAxes* p = _impl_.on_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::telemetry_proto::CompoundAxes&>(::telemetry_proto::_CompoundAxes_default_instance_);
}
inline const ::telemetry_proto::CompoundAxes& Telemetry::on_condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.on_condition)
  return _internal_on_condition();
}
inline void Telemetry::unsafe_arena_set_allocated_on_condition(::telemetry_proto::CompoundAxes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.on_condition_);
  }
  _impl_.on_condition_ = reinterpret_cast<::telemetry_proto::CompoundAxes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry_proto.Telemetry.on_condition)
}
inline ::telemetry_proto::CompoundAxes* Telemetry::release_on_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::telemetry_proto::CompoundAxes* released = _impl_.on_condition_;
  _impl_.on_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::telemetry_proto::CompoundAxes* Telemetry::unsafe_arena_release_on_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:telemetry_proto.Telemetry.on_condition)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::telemetry_proto::CompoundAxes* temp = _impl_.on_condition_;
  _impl_.on_condition_ = nullptr;
  return temp;
}
inline ::telemetry_proto::CompoundAxes* Telemetry::_internal_mutable_on_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.on_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_proto::CompoundAxes>(GetArena());
    _impl_.on_condition_ = reinterpret_cast<::telemetry_proto::CompoundAxes*>(p);
  }
  return _impl_.on_condition_;
}
inline ::telemetry_proto::CompoundAxes* Telemetry::mutable_on_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry_proto::CompoundAxes* _msg = _internal_mutable_on_condition();
  // @@protoc_insertion_point(field_mutable:telemetry_proto.Telemetry.on_condition)
  return _msg;
}
inline void Telemetry::set_allocated_on_condition(::telemetry_proto::CompoundAxes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::telemetry_proto::CompoundAxes*>(_impl_.on_condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::telemetry_proto::CompoundAxes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.on_condition_ = reinterpret_cast<::telemetry_proto::CompoundAxes*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry_proto.Telemetry.on_condition)
}

// .telemetry_proto.CompoundAxes probe = 4;
inline bool Telemetry::has_probe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.probe_ != nullptr);
  return value;
}
inline void Telemetry::clear_probe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.probe_ != nullptr) _impl_.probe_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::telemetry_proto::CompoundAxes& Telemetry::_internal_probe() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::telemetry_proto::CompoundAxes* p = _impl_.probe_;
  return p != nullptr ? *p : reinterpret_cast<const ::telemetry_proto::CompoundAxes&>(::telemetry_proto::_CompoundAxes_default_instance_);
}
inline const ::telemetry_proto::CompoundAxes& Telemetry::probe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.probe)
  return _internal_probe();
}
inline void Telemetry::unsafe_arena_set_allocated_probe(::telemetry_proto::CompoundAxes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.probe_);
  }
  _impl_.probe_ = reinterpret_cast<::telemetry_proto::CompoundAxes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry_proto.Telemetry.probe)
}
inline ::telemetry_proto::CompoundAxes* Telemetry::release_probe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::telemetry_proto::CompoundAxes* released = _impl_.probe_;
  _impl_.probe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::telemetry_proto::CompoundAxes* Telemetry::unsafe_arena_release_probe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:telemetry_proto.Telemetry.probe)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::telemetry_proto::CompoundAxes* temp = _impl_.probe_;
  _impl_.probe_ = nullptr;
  return temp;
}
inline ::telemetry_proto::CompoundAxes* Telemetry::_internal_mutable_probe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.probe_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_proto::CompoundAxes>(GetArena());
    _impl_.probe_ = reinterpret_cast<::telemetry_proto::CompoundAxes*>(p);
  }
  return _impl_.probe_;
}
inline ::telemetry_proto::CompoundAxes* Telemetry::mutable_probe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry_proto::CompoundAxes* _msg = _internal_mutable_probe();
  // @@protoc_insertion_point(field_mutable:telemetry_proto.Telemetry.probe)
  return _msg;
}
inline void Telemetry::set_allocated_probe(::telemetry_proto::CompoundAxes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::telemetry_proto::CompoundAxes*>(_impl_.probe_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::telemetry_proto::CompoundAxes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.probe_ = reinterpret_cast<::telemetry_proto::CompoundAxes*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry_proto.Telemetry.probe)
}

// .telemetry_proto.IndividualAxes stalled = 5;
inline bool Telemetry::has_stalled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stalled_ != nullptr);
  return value;
}
inline void Telemetry::clear_stalled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stalled_ != nullptr) _impl_.stalled_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::telemetry_proto::IndividualAxes& Telemetry::_internal_stalled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::telemetry_proto::IndividualAxes* p = _impl_.stalled_;
  return p != nullptr ? *p : reinterpret_cast<const ::telemetry_proto::IndividualAxes&>(::telemetry_proto::_IndividualAxes_default_instance_);
}
inline const ::telemetry_proto::IndividualAxes& Telemetry::stalled() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.stalled)
  return _internal_stalled();
}
inline void Telemetry::unsafe_arena_set_allocated_stalled(::telemetry_proto::IndividualAxes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stalled_);
  }
  _impl_.stalled_ = reinterpret_cast<::telemetry_proto::IndividualAxes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry_proto.Telemetry.stalled)
}
inline ::telemetry_proto::IndividualAxes* Telemetry::release_stalled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::telemetry_proto::IndividualAxes* released = _impl_.stalled_;
  _impl_.stalled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::telemetry_proto::IndividualAxes* Telemetry::unsafe_arena_release_stalled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:telemetry_proto.Telemetry.stalled)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::telemetry_proto::IndividualAxes* temp = _impl_.stalled_;
  _impl_.stalled_ = nullptr;
  return temp;
}
inline ::telemetry_proto::IndividualAxes* Telemetry::_internal_mutable_stalled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.stalled_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_proto::IndividualAxes>(GetArena());
    _impl_.stalled_ = reinterpret_cast<::telemetry_proto::IndividualAxes*>(p);
  }
  return _impl_.stalled_;
}
inline ::telemetry_proto::IndividualAxes* Telemetry::mutable_stalled() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry_proto::IndividualAxes* _msg = _internal_mutable_stalled();
  // @@protoc_insertion_point(field_mutable:telemetry_proto.Telemetry.stalled)
  return _msg;
}
inline void Telemetry::set_allocated_stalled(::telemetry_proto::IndividualAxes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::telemetry_proto::IndividualAxes*>(_impl_.stalled_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::telemetry_proto::IndividualAxes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.stalled_ = reinterpret_cast<::telemetry_proto::IndividualAxes*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry_proto.Telemetry.stalled)
}

// .telemetry_proto.Limits limits = 6;
inline bool Telemetry::has_limits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limits_ != nullptr);
  return value;
}
inline void Telemetry::clear_limits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.limits_ != nullptr) _impl_.limits_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::telemetry_proto::Limits& Telemetry::_internal_limits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::telemetry_proto::Limits* p = _impl_.limits_;
  return p != nullptr ? *p : reinterpret_cast<const ::telemetry_proto::Limits&>(::telemetry_proto::_Limits_default_instance_);
}
inline const ::telemetry_proto::Limits& Telemetry::limits() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.limits)
  return _internal_limits();
}
inline void Telemetry::unsafe_arena_set_allocated_limits(::telemetry_proto::Limits* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limits_);
  }
  _impl_.limits_ = reinterpret_cast<::telemetry_proto::Limits*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry_proto.Telemetry.limits)
}
inline ::telemetry_proto::Limits* Telemetry::release_limits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::telemetry_proto::Limits* released = _impl_.limits_;
  _impl_.limits_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::telemetry_proto::Limits* Telemetry::unsafe_arena_release_limits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:telemetry_proto.Telemetry.limits)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::telemetry_proto::Limits* temp = _impl_.limits_;
  _impl_.limits_ = nullptr;
  return temp;
}
inline ::telemetry_proto::Limits* Telemetry::_internal_mutable_limits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.limits_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_proto::Limits>(GetArena());
    _impl_.limits_ = reinterpret_cast<::telemetry_proto::Limits*>(p);
  }
  return _impl_.limits_;
}
inline ::telemetry_proto::Limits* Telemetry::mutable_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry_proto::Limits* _msg = _internal_mutable_limits();
  // @@protoc_insertion_point(field_mutable:telemetry_proto.Telemetry.limits)
  return _msg;
}
inline void Telemetry::set_allocated_limits(::telemetry_proto::Limits* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::telemetry_proto::Limits*>(_impl_.limits_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::telemetry_proto::Limits*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.limits_ = reinterpret_cast<::telemetry_proto::Limits*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry_proto.Telemetry.limits)
}

// bool control_enabled = 7;
inline void Telemetry::clear_control_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.control_enabled_ = false;
}
inline bool Telemetry::control_enabled() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.control_enabled)
  return _internal_control_enabled();
}
inline void Telemetry::set_control_enabled(bool value) {
  _internal_set_control_enabled(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Telemetry.control_enabled)
}
inline bool Telemetry::_internal_control_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.control_enabled_;
}
inline void Telemetry::_internal_set_control_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.control_enabled_ = value;
}

// bool stall_control = 8;
inline void Telemetry::clear_stall_control() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stall_control_ = false;
}
inline bool Telemetry::stall_control() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.stall_control)
  return _internal_stall_control();
}
inline void Telemetry::set_stall_control(bool value) {
  _internal_set_stall_control(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Telemetry.stall_control)
}
inline bool Telemetry::_internal_stall_control() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stall_control_;
}
inline void Telemetry::_internal_set_stall_control(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stall_control_ = value;
}

// int32 brakes_mode = 9;
inline void Telemetry::clear_brakes_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brakes_mode_ = 0;
}
inline ::int32_t Telemetry::brakes_mode() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.brakes_mode)
  return _internal_brakes_mode();
}
inline void Telemetry::set_brakes_mode(::int32_t value) {
  _internal_set_brakes_mode(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Telemetry.brakes_mode)
}
inline ::int32_t Telemetry::_internal_brakes_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brakes_mode_;
}
inline void Telemetry::_internal_set_brakes_mode(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.brakes_mode_ = value;
}

// bool probe_protected = 10;
inline void Telemetry::clear_probe_protected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.probe_protected_ = false;
}
inline bool Telemetry::probe_protected() const {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.probe_protected)
  return _internal_probe_protected();
}
inline void Telemetry::set_probe_protected(bool value) {
  _internal_set_probe_protected(value);
  // @@protoc_insertion_point(field_set:telemetry_proto.Telemetry.probe_protected)
}
inline bool Telemetry::_internal_probe_protected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.probe_protected_;
}
inline void Telemetry::_internal_set_probe_protected(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.probe_protected_ = value;
}

// .telemetry_proto.Temps temps = 11;
inline bool Telemetry::has_temps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.temps_ != nullptr);
  return value;
}
inline void Telemetry::clear_temps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.temps_ != nullptr) _impl_.temps_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::telemetry_proto::Temps& Telemetry::_internal_temps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::telemetry_proto::Temps* p = _impl_.temps_;
  return p != nullptr ? *p : reinterpret_cast<const ::telemetry_proto::Temps&>(::telemetry_proto::_Temps_default_instance_);
}
inline const ::telemetry_proto::Temps& Telemetry::temps() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry_proto.Telemetry.temps)
  return _internal_temps();
}
inline void Telemetry::unsafe_arena_set_allocated_temps(::telemetry_proto::Temps* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.temps_);
  }
  _impl_.temps_ = reinterpret_cast<::telemetry_proto::Temps*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry_proto.Telemetry.temps)
}
inline ::telemetry_proto::Temps* Telemetry::release_temps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::telemetry_proto::Temps* released = _impl_.temps_;
  _impl_.temps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::telemetry_proto::Temps* Telemetry::unsafe_arena_release_temps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:telemetry_proto.Telemetry.temps)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::telemetry_proto::Temps* temp = _impl_.temps_;
  _impl_.temps_ = nullptr;
  return temp;
}
inline ::telemetry_proto::Temps* Telemetry::_internal_mutable_temps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.temps_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_proto::Temps>(GetArena());
    _impl_.temps_ = reinterpret_cast<::telemetry_proto::Temps*>(p);
  }
  return _impl_.temps_;
}
inline ::telemetry_proto::Temps* Telemetry::mutable_temps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry_proto::Temps* _msg = _internal_mutable_temps();
  // @@protoc_insertion_point(field_mutable:telemetry_proto.Telemetry.temps)
  return _msg;
}
inline void Telemetry::set_allocated_temps(::telemetry_proto::Temps* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::telemetry_proto::Temps*>(_impl_.temps_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::telemetry_proto::Temps*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.temps_ = reinterpret_cast<::telemetry_proto::Temps*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry_proto.Telemetry.temps)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace telemetry_proto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_telemetry_2eproto_2epb_2eh
